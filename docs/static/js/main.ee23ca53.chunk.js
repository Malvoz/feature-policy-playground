(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{29:function(e){e.exports=[{name:"geolocation",description:"The *geolocation* policy controls whether the current document is allowed to use the [Geolocation interface](https://dev.w3.org/geo/api/spec-source.html).  If disabled in any document, calls to both [`getCurrentPosition`](https://dev.w3.org/geo/api/spec-source.html#get-current-position) and [`watchPosition`](https://dev.w3.org/geo/api/spec-source.html#watch-position) must result in the error callback being invoked with `PERMISSION_DENIED`.",links:[{rel:"policy-mdn",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Feature-Policy/geolocation"},{rel:"feature-spec",href:"https://dev.w3.org/geo/api/spec-source.html",note:"Geolocation API"}],tags:["consent-required"],browserSupport:{chrome:{minVersion:60},edge:!1,firefox:{minVersion:65,requiresFlag:!0},safari:!1}},{name:"accelerometer",description:"The sensor policies are *ambient-light-sensor*, *accelerometer*,  *gyroscope*, and *magnetometer*.\n\nA sensor feature controls access to a device sensor of a certain type requested either through an associated [Sensor](https://w3c.github.io/sensors/#the-sensor-interface)-based interface or through an event specified in the [DeviceOrientation Event Specification](https://www.w3.org/TR/orientation-event/).\n\nIf an interface (or an event) requires access to multiple sensors of different types than each of the corresponding sensor features MUST be allowed in order to use this interface. The table below shows which sensor features are required by the existing interfaces and events.",links:[{rel:"feature-mdn",href:"https://developer.mozilla.org/en-US/docs/Web/API/Accelerometer",note:"Accelerometer"},{rel:"feature-mdn",href:"https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent",note:"DeviceMotion"},{rel:"policy-spec",href:"https://github.com/w3c/webappsec-feature-policy/blob/master/features.md"}],tags:["sensor"],browserSupport:{chrome:{minVersion:69,requiresFlag:!0},edge:!1,firefox:!1,safari:!1}},{name:"midi",desription:"The *midi* feature controls whether the current document is allowed to use the [Web MIDI API](https://webaudio.github.io/web-midi-api/).\n\nIf disabled in a document, the promise returned by [`requestMIDIAccess()`](https://webaudio.github.io/web-midi-api/#dom-navigator-requestmidiaccess) must reject with a `DOMException`",links:[{rel:"policy-spec",href:"https://github.com/w3c/webappsec-feature-policy/blob/master/features.md"},{rel:"policy-mdn",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Feature-Policy/midi"},{rel:"feature-spec",href:"https://webaudio.github.io/web-midi-api/#dom-navigator-requestmidiaccess"},{rel:"feature-mdn",href:"https://developer.mozilla.org/en-US/docs/Web/API/MIDIAccess"}],tags:["consent-required"],browserSupport:{chrome:{minVersion:60},edge:!1,firefox:{minVersion:65,requiresFlag:!0},safari:!1}},{name:"payment",description:"The *payment* policy controls whether the current document is allowed to use the [PaymentRequest interface](https://w3c.github.io/browser-payment-api/).\n\nIf disallowed in a document, then calls to the [`PaymentRequest` constuctor](https://w3c.github.io/browser-payment-api/#constructor) MUST throw a `SecurityError`.",links:[{rel:"policy-spec",href:"https://github.com/w3c/webappsec-feature-policy/blob/master/features.md"},{rel:"policy-mdn",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Feature-Policy/payment"},{rel:"feature-mdn",href:"https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest"}],browserSupport:{chrome:{minVersion:60},edge:!1,firefox:{minVersion:65,requiresFlag:!0},safari:!1}},{name:"magnetometer",description:"The sensor policies are *ambient-light-sensor*, *accelerometer*,  *gyroscope*, and *magnetometer*.\n\nA sensor feature controls access to a device sensor of a certain type requested either through an associated [Sensor](https://w3c.github.io/sensors/#the-sensor-interface)-based interface or through an event specified in the [DeviceOrientation Event Specification](https://www.w3.org/TR/orientation-event/).\n\nIf an interface (or an event) requires access to multiple sensors of different types than each of the corresponding sensor features MUST be allowed in order to use this interface. The table below shows which sensor features are required by the existing interfaces and events.",tags:["sensor"],browserSupport:{chrome:{minVersion:69,requiresFlag:!0},edge:!1,firefox:!1,safari:!1}},{name:"layout-animations",description:"This policy controls the ability of a document to perform animations that require updates to **layout**, rather than simply *repaints*, which are typically cheaper and allow for smoother animations.  So-called 'layout animations' can require significant CPU and often cannot be rendered smoothly.\n\nIf a document is disallowed from performing layout animations by this policy, only the inital and final states of the animation will be rendered.",browserSupport:{chrome:{minVersion:74},edge:!1,firefox:!1,safari:!1},tags:["anitpattern","performance"]},{name:"vertical-scroll",description:"The `vertical-scroll` policy controls whether a document has the right to override normal scrolling behaviour. When disallowed in a document, calls to `event.preventDefault()` on scroll-related events will be ineffective, the CSS property `touch-action: none` will behave as if it is `touch-action: pan-y`, and `element.scrollIntoView()` will not propagate outside the document (ie. any parent frame that needs to be scrolled in order for the element to be in view, will not be).",links:[{rel:"policy-spec",href:"https://github.com/ehsan-karamad/feature-policy/blob/master/policies/vertical_scroll.md"}]},{name:"camera",description:"The *camera* policy controls access to video input devices requested through the [NavigatorUserMedia interface](https://w3c.github.io/mediacapture-main/getusermedia.html#navigatorusermedia).\n\nIf disabled in a document, then calls to [`getUserMedia()`](https://w3c.github.io/mediacapture-main/getusermedia.html#dom-mediadevices-getusermedia()) MUST NOT grant access to video input devices in that document.",links:[{rel:"policy-spec",href:"https://github.com/w3c/webappsec-feature-policy/blob/master/features.md"},{rel:"feature-spec",href:"https://w3c.github.io/mediacapture-main/getusermedia.html#navigatorusermedia"},{rel:"feature-mdn",href:"https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia"}],tags:["consent-required"],browserSupport:{chrome:{minVersion:60},edge:!1,firefox:{minVersion:65,requiresFlag:!0},safari:!1}},{name:"usb",description:"The *usb* feature controls whether the current document is allowed to use the [WebUSB API](https://wicg.github.io/webusb/).\n\nIf disabled in a document, then calls to the [`getDevices()`](https://wicg.github.io/webusb/#dom-usb-getdevices) should return a promise which rejects with a SecurityError DOMException.",links:[{rel:"policy-spec",href:"https://github.com/w3c/webappsec-feature-policy/blob/master/features.md"},{rel:"feature-spec",href:"https://wicg.github.io/webusb/"},{rel:"feature-mdn",href:"https://developer.mozilla.org/en-US/docs/Web/API/USB/getDevices"}],tags:["consent-required"],browserSupport:{chrome:{minVersion:60},edge:!1,firefox:!1,safari:!1}},{name:"unoptimized-images",description:"When optimizing images, the file size should be kept as small as possible. The larger the download size is, the longer it takes a page to load. Stripping metadata, picking a good image format, and using image compression, are all common ways to optimize an image's file size. `unoptimized-images` is a policy that restricts images to have a file size (in terms of number of bytes) no more than a specified ratio of the image size (width * height) on the web page.\n\nWhen a document is disallowed to use `unoptimized-images` policy, its `<img>` elements whose file sizes are too big will be rendered as placeholder images.\n\n### Specification\n\nThe default maximum file size of an optimized image is calculated as following:\n\n```metadata size limit + byte-per-pixel ratio * image resolution```\n\n* For images of one of the modern formats (JPEG, PNG, GIF, WEBP, and SVG)\n    * The default metadata size limit is tentatively 1KB (1024 bytes).\n    * The default byte-per-pixel ratio is tentatively 0.5.\n* For images of other legacy formats\n    * The metadata size limit is set to 0KB.\n    * The byte-per-pixel ratio is set to 0.",tags:["antipattern","performance"],browserSupport:{chrome:{minVersion:72,requiresFlag:!0},edge:!1,firefox:!1,safari:!1}},{name:"oversized-images",description:"This policy allows a document to serve images whose dimensions are larger than the container in which they are rendered on the page.  Rendering images smaller than their native size is a waste of bandwidth and requires additional CPU.  By default, this policy is allowed, and images may be oversized by an unlimited margin, but documents which are disallowed from doing this, will be allowed to oversize by up to a factor of 2.  If this factor is exceeded by any image on the page, a placeholder image will be rendered instead.",links:[{rel:"policy-spec",href:"https://github.com/w3c/webappsec-feature-policy/blob/master/policies/optimized-images.md"}],tags:["antipattern","performance"],browserSupport:{chrome:{minVersion:72,requiresFlag:!0},edge:!1,firefox:!1,safari:!1}},{name:"legacy-image-formats",description:"This policy controls the ability of the document to render images in legacy image formats.  These are defined as any format other than JPEG, PNG, GIF, WEBP, or SVG.  In documents in which this policy is disallowed, legacy-format images will be rendered with inverted colours.",links:[{rel:"policy-spec",href:"https://github.com/loonybear/feature-policy/blob/images/policies/optimized-images.md#legacy-image-formats-policy"}],tags:["antipattern","performance"],browserSupport:{chrome:{minVersion:68,requiresFlag:!0},edge:!1,firefox:!1,safari:!1}},{name:"picture-in-picture",description:"The *picture-in-picture* policy controls whether the current document is allowed to use [Picture In Picture](http://wicg.github.io/picture-in-picture).  If disallowed in a document, then calls to [`requestPictureInPicture()`](https://wicg.github.io/picture-in-picture/#dom-htmlvideoelement-requestpictureinpicture) MUST throw a `SecurityError` and [`pictureInPictureEnabled`](https://wicg.github.io/picture-in-picture/#dom-document-pictureinpictureenabled) MUST return `false`.",links:[{rel:"feature-spec",href:"https://wicg.github.io/picture-in-picture/"}],browserSupport:{chrome:{minVersion:74},edge:!1,firefox:!1,safari:!1}},{name:"speaker",description:"The *speaker* policy controls access to audio output devices requested through the [NavigatorUserMedia interface](https://w3c.github.io/mediacapture-main/getusermedia.html#navigatorusermedia).\n\nIf disallowed in a document, then calls to [`getUserMedia()`](https://w3c.github.io/mediacapture-main/getusermedia.html#dom-mediadevices-getusermedia()) MUST NOT grant access to audio output devices in that document.",links:[{rel:"policy-spec",href:"https://github.com/w3c/webappsec-feature-policy/blob/master/features.md"}],tags:["consent-required"],browserSupport:{chrome:{minVersion:60},edge:!1,firefox:!1,safari:!1}},{name:"fullscreen",description:"The *fullscreen* policy controls whether the [`requestFullscreen()`](https://fullscreen.spec.whatwg.org/#dom-element-requestfullscreen) method is allowed to request fullscreen.\n\nIf disallowed in any document, the document will not be allowed to use fullscreen.  Triggering full-screen mode can be a jarring experience for users, and can be exploited by content that would otherwise be confined to a small frame.",links:[{rel:"policy-spec",href:"https://github.com/w3c/webappsec-feature-policy/blob/master/features.md"},{rel:"feature-spec",href:"https://fullscreen.spec.whatwg.org/#dom-element-requestfullscreen"},{rel:"feature-mdn",href:"https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen"}],browserSupport:{chrome:{minVersion:60},edge:!1,firefox:{minVersion:65,requiresFlag:!0},safari:!1}},{name:"vr",description:"The *vr* policy controls whether the current document is allowed to use the [WebVR API](https://immersive-web.github.io/webvr/spec/1.1/).\n\nIf disallowed in a document, then calls to the [`getVRDisplays()`](https://immersive-web.github.io/webvr/spec/1.1/#navigator-getvrdisplays-attribute) should return a promise which rejects with a SecurityError DOMException.",links:[{rel:"policy-spec",href:"https://github.com/w3c/webappsec-feature-policy/blob/master/features.md"},{rel:"feature-spec",href:"https://immersive-web.github.io/webvr/spec/1.1/"},{rel:"feature-mdn",href:"https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays"}],browserSupport:{chrome:{minVersion:62},edge:!1,firefox:!1,safari:!1}},{name:"document-domain",description:"The `document-domain` policy controls whether the current document is allowed to set `document.domain`. When this policy is denied to the current document's origin, attempting to set `document.domain` will fail and cause a `SecurityError` `DOMException` to be be thrown.  Changing the value of `document.domain` used to be a common practice to allow cross-origin communication, before better mechanisms such as [postMessage](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) existed, and today there are virtually no good reasons to change it.",links:[{rel:"policy-mdn",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Feature-Policy/document-domain"},{rel:"policy-spec",href:"https://html.spec.whatwg.org/multipage/infrastructure.html#document-domain-feature"},{rel:"feature-mdn",href:"https://developer.mozilla.org/en-US/docs/Web/API/Document/domain"}],browserSupport:{chrome:{minVersion:72},edge:!1,firefox:{minVersion:65,requiresFlag:!0},safari:!1},tags:["antipattern"]},{name:"encrypted-media",description:"The `encrypted-media` policy controls whether encrypted media extensions are available in the document.\n\nIf disabled, the promise returned by `requestMediaKeySystemAccess()` must return a promise which rejects with a `SecurityError` `DOMException` object as its parameter.",links:[{rel:"policy-mdn",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Feature-Policy/encrypted-media"},{rel:"policy-spec",href:"https://github.com/w3c/webappsec-feature-policy/blob/master/features.md"},{rel:"feature-mdn",href:"https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess"}],browserSupport:{chrome:{minVersion:60},edge:!1,firefox:{minVersion:65,requiresFlag:!0},safari:!1}},{name:"autoplay",description:"The *autoplay* feature controls access to autoplay of media requested through the [HTMLMediaElement interface](http://w3c.github.io/html/semantics-embedded-content.html#htmlmediaelement).\n\nIf disabled in a document, then calls to [`play()`](http://w3c.github.io/html/semantics-embedded-content.html#dom-htmlmediaelement-play) without a user gesture will reject the promise with a `NotAllowedError` DOMException object as its parameter. The [`autoplay`](http://w3c.github.io/html/semantics-embedded-content.html#dom-htmlmediaelement-autoplay) attribute will be ignored.",links:[{rel:"policy-spec",href:"https://github.com/w3c/webappsec-feature-policy/blob/master/features.md"},{rel:"feature-spec",href:"http://w3c.github.io/html/semantics-embedded-content.html#htmlmediaelement"},{rel:"policy-mdn",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Feature-Policy/autoplay"},{rel:"feature-mdn",href:"https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/autoplay"}],browserSupport:{chrome:!1,firefox:!1,edge:!1,safari:!1},tags:["antipattern"]},{name:"wake-lock",description:"This policy controls the ability of a document to invoke the [Wake Lock API](https://w3c.github.io/wake-lock/), which allows a webpage to prevent a device from going to sleep if the user becomes idle. If disallowed in the document, a call to `Navigator.requestWakeLock()` will return a promise that rejects.",links:[{rel:"policy-spec",href:"https://w3c.github.io/wake-lock/#dfn-wake-lock-feature"},{rel:"feature-spec",href:"https://w3c.github.io/wake-lock/"},{rel:"feature-mdn",href:"https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestWakeLock"}]},{name:"font-display-late-swap",description:"This policy controls the ability of a document to use the `auto`, `block`, and `swap` values of the [font-display](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-display) CSS property.  If the policy is disallowed for the current document, then any elements with a font-display that is not `fallback` or `optional` will be set to `optional`.\n\nIt's annoying for users when fonts take a long time to load, rendering a page unreadable even though the text is available ('blocking').  Not quite as bad, but still a jarring user experience, is when a fallback font is used and the element is rerendered in the webfont when it is available ('swapping').  Disabling the `font-display-late-swap` policy prevents both of these effects by giving the webfont a very small window of opportunity to load, and if it doesn't load in time, simply not using it at all and continuing to use the fallback instead.",links:[{rel:"feature-mdn",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-display"},{rel:"feature-spec",href:"https://drafts.csswg.org/css-fonts-4/#font-display-desc"},{rel:"policy-spec",href:"https://github.com/w3c/webappsec-feature-policy/blob/master/policies/font-display-late-swap.md"}],browserSupport:{chrome:{minVersion:74}},tags:["antipattern"]},{name:"unsized-media",description:"The `unsized-media` policy controls whether documents are allowed to resize images to their 'natural' size.\n\nWhen a document contains images or videos without explicit dimensions, the size is determined by reading the image data.  This takes time, and therefore causes the document layout to change when the image dimensions become known.  When a document is disallowed to use `unsized-media` with this policy, its `<img>`, `<video>`, and `<svg:image>` elements will adopt a default size (300px X 150px) and will not change size when the image data is loaded, providing a potentially less juddery user experience during page load.",links:[{rel:"policy-spec",href:"https://github.com/w3c/webappsec-feature-policy/blob/master/policies/unsized-media.md"}],tags:["antipattern"],browserSupport:{chrome:{minVersion:66,requiresFlag:!0},edge:!1,firefox:!1,safari:!1}},{name:"ambient-light-sensor",description:"The sensor policies are *ambient-light-sensor*, *accelerometer*,  *gyroscope*, and *magnetometer*.\n\nA sensor feature controls access to a device sensor of a certain type requested either through an associated [Sensor](https://w3c.github.io/sensors/#the-sensor-interface)-based interface or through an event specified in the [DeviceOrientation Event Specification](https://www.w3.org/TR/orientation-event/).\n\nIf an interface (or an event) requires access to multiple sensors of different types than each of the corresponding sensor features MUST be allowed in order to use this interface. The table below shows which sensor features are required by the existing interfaces and events.",tags:["sensor"],browserSupport:{chrome:{minVersion:69,requiresFlag:!0},edge:!1,firefox:!1,safari:!1}},{name:"gyroscope",description:"The sensor policies are *ambient-light-sensor*, *accelerometer*,  *gyroscope*, and *magnetometer*.\n\nA sensor feature controls access to a device sensor of a certain type requested either through an associated [Sensor](https://w3c.github.io/sensors/#the-sensor-interface)-based interface or through an event specified in the [DeviceOrientation Event Specification](https://www.w3.org/TR/orientation-event/).\n\nIf an interface (or an event) requires access to multiple sensors of different types than each of the corresponding sensor features MUST be allowed in order to use this interface. The table below shows which sensor features are required by the existing interfaces and events.",tags:["sensor"],browserSupport:{chrome:{minVersion:69,requiresFlag:!0},edge:!1,firefox:!1,safari:!1}},{name:"document-write",description:"When this policy is disabled, the APIs `document.write`, `document.writeln`, `document.open` and `document.close` will thow a `DOMException` when used.  These APIs have been around since the very early days of the web and using them is a bad idea because they dynamically rewrite your HTML markup and block parsing of the document.",links:[{rel:"policy-spec",href:"https://github.com/w3c/webappsec-feature-policy/blob/master/policies/document-write.md"},{rel:"feature-mdn",href:"https://developer.mozilla.org/en-US/docs/Web/API/Document/write"},{rel:"feature-spec",href:"https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-document-write"}],browserSupport:{chrome:{minVersion:74}},tags:["antipattern","performance"]},{name:"lazyload",description:"The `lazyload` policy grants the ability for a document to control whether assets are loaded lazily, ie. only when the user scrolls the docuement such that the asset is within the visible area of the viewport.\n\nIf the policy is enabled, or not specified, the document has full control over lazy-loading, using the [lazyload](https://docs.google.com/document/d/1e8ZbVyUwgIkQMvJma3kKUDg8UUkLRRdANStqKuOIvHg/edit) attribute of `<img>` and `<iframe>` tags.  If the policy is disabled, the user agent **will lazy-load all assets** regardless of the presence or value of any `lazyload` attribute on the element itself.",links:[{rel:"policy-spec",href:"https://github.com/whatwg/html/pull/3752",note:"Pull request"},{rel:"feature-spec",href:"https://docs.google.com/document/d/1e8ZbVyUwgIkQMvJma3kKUDg8UUkLRRdANStqKuOIvHg/edit",note:"Google doc"}],browserSupport:{chrome:!1},tags:["performance"]},{name:"sync-script",description:"The *sync-script* policy controls whether a document will execute parser-blocking JavaScript.  This includes both external `<script src=''>` resources that do not have the `async` or `defer` attributes, but also any inline script that is not an ES module, and which does not have a `defer` attribute.  Blocked scripts will be skipped by the parser completely, ie. they are not simply forced to execute asynchronously, since that may result in unexpected behaviour.",links:[{rel:"policy-spec",href:"https://github.com/w3c/webappsec-feature-policy/issues/135",note:"Tracking issue"}],tags:["antipattern","performance"]},{name:"sync-xhr",description:"The *sync-xhr* policy controls whether synchronous requests can be made through the [XMLHttpRequest API](https://xhr.spec.whatwg.org/).\n\nIf disallowed in a document, then calls to [`send()`](https://xhr.spec.whatwg.org/#the-send()-method) on `XMLHttpRequest` objects with the synchronous flag set will fail, causing a NetworkError DOMException to be thrown.",links:[{rel:"policy-spec",href:"https://github.com/w3c/webappsec-feature-policy/blob/master/features.md"},{rel:"feature-spec",href:"https://xhr.spec.whatwg.org/#the-send()-method"},{rel:"feature-mdn",href:"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/open"}],tags:["antipattern","performance"],browserSupport:{chrome:{minVersion:65,requiresFlag:!0},edge:!1,firefox:!1,safari:!1}},{name:"microphone",description:"The *microphone* policy controls access to audio input devices requested through the [NavigatorUserMedia interface](https://w3c.github.io/mediacapture-main/getusermedia.html#navigatorusermedia).\n\nIf disallowed in a document, then calls to [`getUserMedia()`](https://w3c.github.io/mediacapture-main/getusermedia.html#dom-mediadevices-getusermedia()) MUST NOT grant access to audio input devices in that document.",links:[{rel:"policy-spec",href:"https://github.com/w3c/webappsec-feature-policy/blob/master/features.md"},{rel:"feature-spec",href:"https://w3c.github.io/mediacapture-main/getusermedia.html#navigatorusermedia"},{rel:"policy-mdn",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Feature-Policy/microphone"},{rel:"feature-mdn",href:"https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia"}],tags:["user-consent"],browserSupport:{chrome:{minVersion:60},edge:!1,firefox:{minVersion:65,requiresFlag:!0},safari:!1}}]},347:function(e,t,a){"use strict";a.r(t);var r,o=a(0),i=a.n(o),n=a(27),s=a.n(n),l=a(7),c=a(8),u=a(10),d=a(9),m=a(11),h=(a(57),a(2)),p=a(47),f=function(){var e=r.routes.find(function(e){return e.pattern.test(window.location.pathname)});if(e){var t=e.pattern.exec(window.location.pathname)||{},a=window.location.search.replace(/^\?/,"").split("&").filter(function(e){return e.length}).map(function(e){return e.split("=")}).reduce(function(e,t){return Object(p.a)({},e,Object(h.a)({},t[0],t[1]))},{}),o=e.action(t,a,window.location.href);"function"===typeof r.onRoute&&r.onRoute(o)}},g=function(e,t,a){var o="replace"===a?"replaceState":"pushState";if(e!==window.location.pathname&&window.history[o]({},"",e),void 0!==t){var i=[];r.title&&r.title.prefix&&i.push(r.title.prefix),t&&i.push(t),r.title&&r.title.suffix&&i.push(r.title.suffix),document.title=i.join(r.title.delim||" | ")}},b=function(e){return i.a.createElement("a",{className:e.className,href:e.to,onClick:function(t){t.shiftKey||t.controlKey||t.metaKey||t.altKey||r.routes.find(function(t){return t.pattern.test(e.to)})&&(t.preventDefault(),window.history.pushState({},"",e.to),f(),window.scrollTo(0,0))}},e.children)};window.addEventListener("popstate",function(e){return f()});var w=function(e){return i.a.createElement("header",null,i.a.createElement("div",{className:"container"},i.a.createElement("h1",null,i.a.createElement(b,{to:"/"},"Feature policy playground"))))},y=function(e){return i.a.createElement("main",{className:"about"},i.a.createElement("p",null,"Feature Policy allows you to control which origins can use which features, both in the top-level page and in embedded frames. Essentially, you write a policy, which is an allowed list of origins for each feature. For every feature controlled by Feature Policy, the feature is only enabled in the current document or frame if its origin matches the allowed list of origins."),i.a.createElement("p",null,"For each policy-controlled feature, the browser maintains a list of origins for which the feature is enabled, known as an allowlist. If you do not specify a policy for a feature, then a default allowlist will be used. The default allowlist is specific to each feature."),i.a.createElement("p",null,"Click a feature to start exploring."))},v=a(19),E=a(28),k=a.n(E),S=a(48),T=a(49),x=a.n(T),I=a(15),P=a.n(I),N=a(50),q=a(13),M=a(14),z=a.n(M),F="PENDING",D="UNEXPECTED_SUCCESS",U="UNEXPECTED_FAIL",W=function(e){function t(e){var a;return Object(l.a)(this,t),(a=Object(u.a)(this,Object(d.a)(t).call(this,e))).state={status:F,detail:null,longWait:!1},a.boundHandleReceiveMessage=a.handleReceiveMessage.bind(Object(q.a)(Object(q.a)(a))),a.longWaitTimer=null,a}return Object(m.a)(t,e),Object(c.a)(t,[{key:"componentDidMount",value:function(){window.addEventListener("message",this.boundHandleReceiveMessage,!1)}},{key:"componentWillUnmount",value:function(){window.removeEventListener("message",this.boundHandleReceiveMessage,!1)}},{key:"componentDidUpdate",value:function(e){var t=this;this.props.id!==e.id&&(this.setState({status:F,detail:null,longWait:!1}),clearTimeout(this.longWaitTimer),this.longWaitTimer=setTimeout(function(){return t.setState({longWait:!0})},2e3))}},{key:"handleReceiveMessage",value:function(e){"feature-test-result"===e.data.type&&Number.parseInt(e.data.demoID,10)===Number.parseInt(this.props.id,10)&&(e.data.isWorking&&this.props.expectToWork?this.setState({status:"OK"}):e.data.isWorking||this.props.expectToWork?e.data.isWorking&&!this.props.expectToWork?this.setState({status:D}):this.setState({status:U}):this.setState({status:"EXPECTED_FAIL"}),this.setState({detail:e.data.resultDetail}),clearTimeout(this.longWaitTimer))}},{key:"render",value:function(){var e,t=(e={},Object(h.a)(e,F,"Waiting for the demo to report a result..."),Object(h.a)(e,"OK","The feature worked, and it was allowed by the Feature Policy"),Object(h.a)(e,"EXPECTED_FAIL","The feature didn't work, but we didn't expect it to, because it was blocked by the Feature Policy"),Object(h.a)(e,D,"The feature worked despite being blocked by a Feature Policy.  Perhaps this policy is not recognised by this browser"),Object(h.a)(e,U,"The feature didn't work, but was allowed by the Feature Policy.  Perhaps the feature is not supported in this browser"),e),a=z()({result:!0,alert:!0,"alert-info":this.state.status===F,"alert-success":"OK"===this.state.status,"alert-secondary":"EXPECTED_FAIL"===this.state.status,"alert-danger":[D,U].includes(this.state.status)});return i.a.createElement("div",{className:a},Boolean(this.state.status===F)&&i.a.createElement("div",{className:"spinner-grow",role:"status"},i.a.createElement("span",{className:"sr-only"},"Loading...")),i.a.createElement("div",{className:"content"},i.a.createElement("p",null,t[this.state.status],this.state.status===F&&this.state.longWait&&i.a.createElement("span",null," (you may need to interact with the demo)")),Boolean(this.state.detail)&&i.a.createElement("p",{className:"detail"},this.state.detail)))}}]),t}(o.Component);function A(){return Math.round(1e5*Math.random())}var O=function(e){function t(e){var a;return Object(l.a)(this,t),(a=Object(u.a)(this,Object(d.a)(t).call(this,e))).state={feature:null,policyAllowed:!0,demoID:null,demoCode:null},a}return Object(m.a)(t,e),Object(c.a)(t,[{key:"componentDidMount",value:function(){this.resetAndLoad()}},{key:"componentDidUpdate",value:function(){this.resetAndLoad()}},{key:"setPolicyAllowed",value:function(e){this.setState({policyAllowed:Boolean(e),demoID:this.state.demoID?A():null})}},{key:"resetAndLoad",value:function(){var e=Object(S.a)(k.a.mark(function e(){var t,a;return k.a.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(this.props.feature.name===this.state.feature){e.next=11;break}return this.setState({feature:this.props.feature.name,policyAllowed:!0,demoID:null,demoHtml:null,demoScript:null}),e.next=4,fetch("/demos/"+this.props.feature.name+".json",{headers:{Accept:"application/json"}});case 4:if(!(t=e.sent).ok){e.next=11;break}return e.next=8,t.json();case 8:if(!(a=e.sent).script&&!a.html){e.next=11;break}return e.abrupt("return",this.setState({demoID:A(),demoCode:a}));case 11:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"render",value:function(){var e=this,t=this.props.feature,a={"policy-spec":"Specification for "+t.name+" feature policy","policy-mdn":t.name+" feature policy on MDN","feature-spec":"Feature specification","feature-mdn":"Documentation for the feature on MDN"},r="Feature-Policy: ".concat(t.name," 'none'"),o=Object.assign({edge:!1,safari:!1},t.browserSupport),n={url:"https://featurepolicy.info"+window.location.pathname,identifier:this.props.feature.name,title:this.props.feature.name};return i.a.createElement("main",{className:"feature col-12"},i.a.createElement("div",{className:"feature-header"},Boolean(t.tags)&&i.a.createElement("div",{className:"tags"},t.tags.map(function(e){return i.a.createElement("span",{key:e,className:"badge badge-light"},e)})),i.a.createElement("h2",null,t.name)),Boolean(t.description)&&i.a.createElement("div",{className:"feature-description lead"},i.a.createElement(x.a,{source:t.description})),i.a.createElement("section",{className:"setup-instructions"},i.a.createElement("h3",null,"How to apply this policy"),i.a.createElement("p",null,"Send the following HTTP header to control the ",i.a.createElement("code",null,t.name)," policy, and disallow it on all origins:"),i.a.createElement(P.a,{language:"http"},r)),Boolean(this.state.demoID)&&i.a.createElement("section",{className:"test-case"},i.a.createElement("div",{className:"policy-toggle"},i.a.createElement("h3",null,"Affected use case example"),i.a.createElement("div",{className:"custom-control custom-switch"},i.a.createElement("input",{type:"checkbox",className:"custom-control-input",id:"policyToggle",checked:this.state.policyAllowed,onChange:function(t){return e.setPolicyAllowed(t.target.checked)}}),i.a.createElement("label",{className:"custom-control-label",htmlFor:"policyToggle"},"Allow policy"))),i.a.createElement("div",{className:"demo-container row px-sm-2 mx-sm-0"},i.a.createElement("div",{className:"demo-code-blocks col-lg-6 px-sm-2"},Boolean(this.state.demoCode.css)&&i.a.createElement("div",null,i.a.createElement("h4",null,"CSS"),i.a.createElement(P.a,{language:"css"},this.state.demoCode.css)),Boolean(this.state.demoCode.html)&&i.a.createElement("div",null,i.a.createElement("h4",null,"HTML"),i.a.createElement(P.a,{language:"html"},this.state.demoCode.html)),Boolean(this.state.demoCode.script)&&i.a.createElement("div",null,i.a.createElement("h4",null,"JavaScript"),i.a.createElement(P.a,{language:"javascript"},this.state.demoCode.script))),i.a.createElement("div",{className:"demo-output col-lg-6 px-sm-2"},i.a.createElement("h4",null,"Output"),i.a.createElement("iframe",{title:"Demo output",src:"/demos/"+t.name+".html?demoID="+this.state.demoID,allow:t.name+" "+(this.state.policyAllowed?"*":"'none'"),key:A()}))),i.a.createElement(W,{id:this.state.demoID,expectToWork:this.state.policyAllowed})),i.a.createElement("section",{className:"does-it-work"},i.a.createElement("h3",null,"Does it work?"),i.a.createElement("p",null,"Currently Firefox, and Chromium based browsers, such as Google Chrome, Samsung Internet, and Opera, are the only user-agents to support Feature Policy.  The minimum version that correctly recognises the ",i.a.createElement("code",null,t.name)," policy is:"),i.a.createElement("div",{className:"row"},Object.entries({firefox:"Mozilla Firefox",chrome:"Google Chrome",edge:"Microsoft Edge",safari:"Apple Safari"}).map(function(e){var t=Object(v.a)(e,2),a=t[0],r=t[1],n=a in o?o[a]?"supported":"unsupported":"unknown";return i.a.createElement("div",{key:a,className:"col-lg-3 col-sm-6"},i.a.createElement("div",{className:"browser-support card "+n},i.a.createElement("img",{src:"/browser-logos/"+a+".svg",className:"card-img-top",alt:r}),i.a.createElement("div",{className:"card-body"},"supported"===n&&i.a.createElement("p",{className:"card-text"},i.a.createElement("i",{className:"fas fa-check-circle"}),o[a].minVersion,"+"),"unsupported"===n&&i.a.createElement("p",{className:"card-text"},i.a.createElement("i",{className:"fas fa-times-circle"}),"Not supported"),"unknown"===n&&i.a.createElement("p",{className:"card-text"},"Unknown"))))}))),Boolean(t.links)&&i.a.createElement("section",{className:"links"},i.a.createElement("h3",null,"See also"),i.a.createElement("ul",null,t.links.map(function(e){return i.a.createElement("li",{key:e.href},i.a.createElement("a",{href:e.href,className:e.rel},a[e.rel],e.note&&" ("+e.note+")"))}))),i.a.createElement("section",{className:"discuss"},i.a.createElement("h3",null,"Discussion"),i.a.createElement(N.DiscussionEmbed,{shortname:"featurepolicy",config:n})))}}]),t}(i.a.Component),j=function(e){var t=e.policies;return i.a.createElement("div",{className:"row"},i.a.createElement("div",{className:"col-12"},i.a.createElement("table",{className:"features-list"},i.a.createElement("thead",null,i.a.createElement("tr",null,i.a.createElement("th",null,"Policy"),i.a.createElement("th",null,"Support"),i.a.createElement("th",null,"Docs"))),i.a.createElement("tbody",null,t.sort(function(e,t){return e.name<t.name?-1:1}).map(function(e){var t=z()({"policy-allowed":window.featurePolicy&&window.featurePolicy.allowsFeature(e.name)});return i.a.createElement("tr",{key:e.name},i.a.createElement("td",null,i.a.createElement(b,{to:"/policies/"+e.name,className:t},e.name)),i.a.createElement("td",null,e.browserSupport&&Object.entries(e.browserSupport).map(function(e){var t=Object(v.a)(e,2),a=t[0],r=t[1],o=z()({browser:!0,"requires-flag":r.requiresFlag});return!!r.minVersion&&i.a.createElement("div",{key:a,className:o},i.a.createElement("img",{src:"/browser-logos/"+a+".svg",className:o,alt:a}),r.minVersion,r.requiresFlag&&i.a.createElement("i",{className:"fas fa-flag"}))})),i.a.createElement("td",{className:"links"},e.links&&e.links.filter(function(e){return e.rel.endsWith("-mdn")}).map(function(e){return i.a.createElement("a",{key:e.href,href:e.href},e.note||(e.rel.startsWith("feature-")?"Feature":"Policy"))})))})))))},V=function(e){return i.a.createElement("footer",{className:"text-muted"},i.a.createElement("div",{className:"container"},i.a.createElement("ul",{className:"footer-links"},i.a.createElement("li",null,i.a.createElement("a",{href:"https://github.com/triblondon/feature-policy-playground"},"GitHub repo")),i.a.createElement("li",null,i.a.createElement("a",{href:"https://twitter.com/triblondon"},"Follow me on twitter"))),i.a.createElement("p",null,"Created by ",i.a.createElement("a",{href:"https://trib.tv/"},"Andrew Betts"),".  MIT Licence, unless otherwise indicated.")))},C=a(29),H=function(e){function t(e){var a;return Object(l.a)(this,t),(a=Object(u.a)(this,Object(d.a)(t).call(this,e))).state={activeFeature:null},a}return Object(m.a)(t,e),Object(c.a)(t,[{key:"componentDidMount",value:function(){var e=this;(r={routes:[{name:"empty",pattern:/^\/$/,action:function(){return e.setPolicy(null)}},{name:"policy",pattern:/^\/policies\/([^\/]+)\/?$/,action:function(t){return e.setPolicy(t[1])}}],title:{suffix:"Feature policy",delim:" - "},triggerForInitialState:!0}).triggerForInitialState&&f()}},{key:"setPolicy",value:function(e){this.setState(function(t){if(t.activeFeature!==e)return{activeFeature:e}}),g(e?"/policies/"+e:"/",e,"push")}},{key:"render",value:function(){var e=this;return i.a.createElement("div",null,i.a.createElement(w,null),i.a.createElement("div",{className:"container"},Boolean(this.state.activeFeature)?i.a.createElement("div",{className:"row"},i.a.createElement(O,{feature:C.find(function(t){return t.name===e.state.activeFeature})})):i.a.createElement("div",null,i.a.createElement(y,null),i.a.createElement(j,{policies:C,activeFeature:this.state.activeFeature,onChange:function(t){return e.setPolicy(t)}}),i.a.createElement("p",null,"Browser support data courtesy of MDN's ",i.a.createElement("a",{href:"https://github.com/mdn/browser-compat-data"},"public browser-compat-data")," project."))),i.a.createElement(V,null))}}]),t}(o.Component);window.featurePolicy=document.featurePolicy||document.policy,"serviceWorker"in navigator&&navigator.serviceWorker.register("/sw.js"),s.a.render(i.a.createElement(H,null),document.getElementById("root"))},51:function(e,t,a){e.exports=a(347)},57:function(e,t,a){}},[[51,1,2]]]);
//# sourceMappingURL=main.ee23ca53.chunk.js.map